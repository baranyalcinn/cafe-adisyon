// @ts-nocheck
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async getAllTables() : Promise<Result<TableResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_tables") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createTable(name: string) : Promise<Result<TableResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_table", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteTable(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_table", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTableStatus() : Promise<Result<TableStatusResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_table_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAllCategories() : Promise<Result<CategoryResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_categories") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createCategory(name: string) : Promise<Result<CategoryResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_category", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCategory(id: string, data: UpdateCategoryInput) : Promise<Result<CategoryResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_category", { id, data }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteCategory(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_category", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAllProducts() : Promise<Result<ProductResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_products") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getProductsByCategory(categoryId: string) : Promise<Result<ProductResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_products_by_category", { categoryId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getFavoriteProducts() : Promise<Result<ProductResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_favorite_products") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async searchProducts(query: string) : Promise<Result<ProductResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_products", { query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createProduct(data: CreateProductInput) : Promise<Result<ProductResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_product", { data }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateProduct(id: string, data: UpdateProductInput) : Promise<Result<ProductResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_product", { id, data }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteProduct(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_product", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getOpenOrderByTable(tableId: string) : Promise<Result<OrderResponse | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_open_order_by_table", { tableId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createOrder(tableId: string) : Promise<Result<OrderResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_order", { tableId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateOrder(id: string, input: UpdateOrderInput) : Promise<Result<OrderResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_order", { id, input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addOrderItem(orderId: string, productId: string, quantity: number, notes: string | null) : Promise<Result<OrderResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_order_item", { orderId, productId, quantity, notes }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateOrderItem(itemId: string, quantity: number, notes: string | null) : Promise<Result<OrderResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_order_item", { itemId, quantity, notes }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeOrderItem(itemId: string) : Promise<Result<OrderResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_order_item", { itemId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteOrder(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_order", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async transferOrder(id: string, toTableId: string) : Promise<Result<OrderResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("transfer_order", { id, toTableId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async mergeOrders(sourceOrderId: string, targetOrderId: string) : Promise<Result<OrderResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("merge_orders", { sourceOrderId, targetOrderId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async markItemsPaid(items: MarkItemPaidInput[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("mark_items_paid", { items }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getOrderHistory(date: string | null, limit: number | null, offset: number | null) : Promise<Result<OrderHistoryResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_order_history", { date, limit, offset }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getOrderDetails(orderId: string) : Promise<Result<OrderResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_order_details", { orderId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createPayment(orderId: string, amount: number, paymentMethod: string) : Promise<Result<PaymentResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_payment", { orderId, amount, paymentMethod }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPaymentsByOrder(orderId: string) : Promise<Result<TransactionResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_payments_by_order", { orderId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDashboardStats() : Promise<Result<DashboardStats, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_dashboard_stats") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getExtendedDashboardStats() : Promise<Result<ExtendedDashboardStats, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_extended_dashboard_stats") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRevenueTrend(days: number | null) : Promise<Result<RevenueTrendItem[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_revenue_trend", { days }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async verifyPin(pin: string) : Promise<Result<PinCheckResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("verify_pin", { pin }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkAdminStatus() : Promise<Result<StatusResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_admin_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePin(currentPin: string, newPin: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_pin", { currentPin, newPin }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setRecovery(currentPin: string, question: string, answer: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_recovery", { currentPin, question, answer }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecoveryQuestion() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recovery_question") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetPin(answer: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_pin", { answer }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createExpense(data: CreateExpenseInput) : Promise<Result<ExpenseResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_expense", { data }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateExpense(id: string, data: UpdateExpenseInput) : Promise<Result<ExpenseResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_expense", { id, data }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAllExpenses() : Promise<Result<ExpenseResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_expenses") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteExpense(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_expense", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecentLogs(limit: number | null, startDate: string | null, endDate: string | null, offset: number | null, search: string | null) : Promise<Result<LogResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recent_logs", { limit, startDate, endDate, offset, search }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createLog(action: string, tableName: string | null, userName: string | null, details: string | null) : Promise<Result<LogResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_log", { action, tableName, userName, details }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async generateZreport(actualCash: number | null) : Promise<Result<DailySummaryResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_zreport", { actualCash }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getZreportHistory(limit: number | null, startDate: string | null, endDate: string | null) : Promise<Result<DailySummaryResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_zreport_history", { limit, startDate, endDate }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMonthlyReports(limit: number | null) : Promise<Result<MonthlyReportResponse[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_monthly_reports", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async archiveOldData() : Promise<Result<ArchiveResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("archive_old_data") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async vacuumDatabase() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("vacuum_database") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkEndOfDay() : Promise<Result<EndOfDayCheckResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_end_of_day") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async systemCheck() : Promise<Result<SystemCheck, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("system_check") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backupDatabase() : Promise<Result<BackupResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backup_database") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backupDatabaseWithRotation(maxBackups: number | null) : Promise<Result<BackupResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backup_database_with_rotation", { maxBackups }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async executeEndOfDay(actualCash: number | null) : Promise<Result<EndOfDayExecutionResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("execute_end_of_day", { actualCash }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async exportDatabase() : Promise<Result<ExportResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_database") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async seedDatabase() : Promise<Result<SeedResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("seed_database") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async importLegacyData(filePath: string | null) : Promise<Result<ImportResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_legacy_data", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type ArchiveResult = { deletedOrders: number; deletedItems: number; deletedTransactions: number; deletedExpenses: number; deletedSummaries: number }
export type BackupResult = { success: boolean; path: string; deletedCount: number; totalBackups: number }
export type CategoryBreakdownItem = { categoryName: string; revenue: number; quantity: number }
export type CategoryResponse = { id: string; name: string; icon: string | null }
export type CreateExpenseInput = { description: string; amount: number; category: string | null; paymentMethod: string | null }
export type CreateProductInput = { name: string; price: number; categoryId: string; isFavorite: boolean }
export type DailySummaryResponse = { id: string; date: string; totalCash: number; actualCash: number | null; totalCard: number; totalExpenses: number; netProfit: number; cancelCount: number; totalVat: number; orderCount: number; totalRevenue: number; createdAt: string | null }
export type DashboardStats = { dailyRevenue: number; totalOrders: number; paymentMethodBreakdown: PaymentBreakdown; topProducts: TopProduct[] }
export type EndOfDayCheckResult = { canProceed: boolean; openTables: OpenTableInfo[] }
export type EndOfDayExecutionResult = { zReportId: string | null; backupPath: string; vacuumSuccess: boolean }
export type ExpenseResponse = { id: string; description: string; amount: number; category: string | null; paymentMethod: string | null; createdAt: string | null }
export type ExportResult = { filepath: string; count: number }
export type ExtendedDashboardStats = { dailyRevenue: number; totalOrders: number; paymentMethodBreakdown: PaymentBreakdown; topProducts: TopProduct[]; openTables: number; pendingOrders: number; hourlyActivity: HourlyActivity[]; categoryBreakdown: CategoryBreakdownItem[]; bottomProducts: TopProduct[]; dailyExpenses: number }
export type HourlyActivity = { hour: string; revenue: number; orderCount: number }
export type ImportResult = { success: boolean; message: string; tablesProcessed: number; errors: string[] }
export type LogResponse = { id: string; action: string; tableName: string | null; userName: string | null; details: string | null; createdAt: string | null }
export type MarkItemPaidInput = { id: string; quantity: number }
export type MonthlyReportResponse = { id: string; monthDate: string; totalRevenue: number; totalExpenses: number; netProfit: number; orderCount: number; updatedAt: string | null }
export type OpenTableInfo = { tableId: string; tableName: string; orderId: string; totalAmount: number }
export type OrderHistoryResult = { orders: OrderResponse[]; totalCount: number; hasMore: boolean }
export type OrderItemResponse = { id: string; orderId: string; productId: string; quantity: number; unitPrice: number; isPaid: boolean; productName: string | null }
export type OrderResponse = { id: string; tableId: string; status: string; totalAmount: number; isLocked: boolean; createdAt: string | null; updatedAt: string | null; items: OrderItemResponse[]; payments: TransactionResponse[] }
export type PaymentBreakdown = { cash: number; card: number }
export type PaymentResult = { order: OrderResponse; completed: boolean }
export type PinCheckResult = { valid: boolean; required: boolean }
export type ProductResponse = { id: string; name: string; price: number; categoryId: string; isFavorite: boolean; isDeleted: boolean }
export type RevenueTrendItem = { date: string; revenue: number; orderCount: number }
export type SeedResult = { categories: number; products: number; tables: number }
export type StatusResult = { required: boolean }
export type SystemCheck = { dbConnected: boolean; tableCount: number; productCount: number }
export type TableResponse = { id: string; name: string }
export type TableStatusResponse = { id: string; name: string; hasOpenOrder: boolean; isLocked: boolean }
export type TopProduct = { productId: string; productName: string; quantity: number }
export type TransactionResponse = { id: string; orderId: string; amount: number; paymentMethod: string; createdAt: string | null }
export type UpdateCategoryInput = { name: string | null; icon: string | null }
export type UpdateExpenseInput = { description: string | null; amount: number | null; category: string | null; paymentMethod: string | null }
export type UpdateOrderInput = { status: string | null; totalAmount: number | null; isLocked: boolean | null }
export type UpdateProductInput = { name: string | null; price: number | null; isFavorite: boolean | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}

Mevcut kodunuz oldukça temiz ve modern yaklaşımları (React Query, Zustand, Framer Motion, Tailwind) zaten kullanıyor. Ancak "daha iyi tepki" (performance), "daha kaliteli" (DX/Architecture) ve "optimize" (UX) bir yapı için şu iyileştirmeleri yapabiliriz:

Yapılan Başlıca İyileştirmeler:

Theme Logic'in Ayrılması: Tema ve renk şeması mantığını useTheme gibi özel bir hook'a veya Provider'a taşıyarak App.tsx üzerindeki yükü azalttık.

Navigation Logic'in Soyutlanması: Sidebar ve navigasyon elemanlarını ayrı bir bileşene taşıyarak okunabilirliği artırdık.

Performans (Memoization): View geçişlerinde gereksiz render'ları önlemek için useCallback ve memo kullanımını değerlendirdik.

UX/Erişilebilirlik: Tooltip eklemeleri ve daha akıcı Framer Motion varyantları.

Layout Kararlılığı: AnimatePresence içinde mode="wait" veya mode="popLayout" kullanarak sayfa geçişlerindeki zıplamaları engelledik.

İşte modernize edilmiş versiyon:

1. Tema Yönetimi (Hooks/useTheme.ts)

Tema mantığını buraya taşıyarak App.tsx'i temizliyoruz.

code
TypeScript
download
content_copy
expand_less
import { useState, useEffect } from 'react'

export type ColorScheme = 'emerald' | 'ocean' | 'violet' | 'amber' | 'rose'

export function useTheme() {
  const [isDark, setIsDark] = useState(() => localStorage.getItem('theme') !== 'light')
  const [colorScheme, setColorScheme] = useState<ColorScheme>(
    () => (localStorage.getItem('colorScheme') as ColorScheme) || 'emerald'
  )

  useEffect(() => {
    document.documentElement.classList.toggle('dark', isDark)
    localStorage.setItem('theme', isDark ? 'dark' : 'light')
  }, [isDark])

  useEffect(() => {
    document.documentElement.setAttribute('data-scheme', colorScheme)
    localStorage.setItem('colorScheme', colorScheme)
  }, [colorScheme])

  return { isDark, toggleTheme: () => setIsDark(!isDark), colorScheme, setColorScheme }
}
2. Optimize Edilmiş App Bileşeni (App.tsx)
code
Tsx
download
content_copy
expand_less
import { Suspense, lazy, useCallback } from 'react'
import { LayoutGrid, Settings, Loader2 } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { TablesView } from '@/features/tables/TablesView'
import { OrderView } from '@/features/orders/OrderView'
import { useTableStore } from '@/store/useTableStore'
import { useInventoryPrefetch } from '@/hooks/useInventory'
import { cn } from '@/lib/utils'
import { Toaster } from '@/components/ui/toaster'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { TitleBar } from '@/components/TitleBar'
import { AnimatePresence, motion } from 'framer-motion'
import { useTheme } from '@/hooks/useTheme'

const SettingsView = lazy(() =>
  import('@/features/settings/SettingsView').then((m) => ({ default: m.SettingsView }))
)

type ViewType = 'tables' | 'order' | 'settings'

const viewVariants = {
  initial: (direction: number) => ({
    opacity: 0,
    x: direction > 0 ? 20 : -20,
    scale: 0.98
  }),
  animate: {
    opacity: 1,
    x: 0,
    scale: 1,
    transition: { type: 'spring', stiffness: 300, damping: 30 }
  },
  exit: (direction: number) => ({
    opacity: 0,
    x: direction < 0 ? 20 : -20,
    scale: 0.98,
    transition: { duration: 0.2 }
  })
}

function App(): React.JSX.Element {
  const [currentView, setCurrentView] = useState<ViewType>('tables')
  const { isDark, toggleTheme, colorScheme, setColorScheme } = useTheme()
  const { selectTable } = useTableStore()
  
  // Prefetch logic (Sadece mount anında bir kez çalışır)
  const { prefetchAll } = useInventoryPrefetch()
  useEffect(() => { prefetchAll() }, [prefetchAll])

  const handleTableSelect = useCallback((tableId: string) => {
    selectTable(tableId)
    setCurrentView('order')
  }, [selectTable])

  const handleBackToTables = useCallback(() => {
    selectTable(null)
    setCurrentView('tables')
  }, [selectTable])

  return (
    <div className="h-screen flex flex-col overflow-hidden bg-background text-foreground">
      <TitleBar />

      <div className="flex-1 flex overflow-hidden">
        {/* Sidebar - Ayrıştırılmış ve daha temiz */}
        <aside className="w-20 flex flex-col items-center py-6 bg-card/50 backdrop-blur-xl border-r z-50 transition-colors">
          <LogoSection />
          
          <nav className="flex-1 flex flex-col gap-4 pt-8">
            <NavButton 
              active={currentView === 'tables'} 
              onClick={() => setCurrentView('tables')}
              icon={LayoutGrid}
              label="Masalar"
            />
          </nav>

          <div className="pb-4">
            <NavButton 
              active={currentView === 'settings'} 
              onClick={() => setCurrentView('settings')}
              icon={Settings}
              label="Ayarlar"
            />
          </div>
        </aside>

        {/* Main Content Area */}
        <main className="flex-1 relative bg-muted/5">
          <AnimatePresence mode="wait" initial={false}>
            <motion.div
              key={currentView}
              variants={viewVariants}
              initial="initial"
              animate="animate"
              exit="exit"
              className="absolute inset-0 overflow-auto"
            >
              <Suspense fallback={<LoadingFallback />}>
                {currentView === 'tables' && <TablesView onTableSelect={handleTableSelect} />}
                {currentView === 'order' && <OrderView onBack={handleBackToTables} />}
                {currentView === 'settings' && (
                  <SettingsView
                    isDark={isDark}
                    onThemeToggle={toggleTheme}
                    colorScheme={colorScheme}
                    onColorSchemeChange={setColorScheme}
                  />
                )}
              </Suspense>
            </motion.div>
          </AnimatePresence>
        </main>
      </div>

      <Toaster />
      <ReactQueryDevtools initialIsOpen={false} />
    </div>
  )
}

// Alt Bileşenler (Okunabilirliği artırmak için)

function NavButton({ active, onClick, icon: Icon, label }: any) {
  return (
    <div className="relative group px-2">
      <AnimatePresence>
        {active && (
          <motion.div 
            layoutId="activeNav"
            className="absolute left-0 w-1 h-8 bg-primary rounded-r-full shadow-[0_0_15px_rgba(var(--primary),0.5)]" 
          />
        )}
      </AnimatePresence>
      <Button
        variant="ghost"
        size="icon"
        onClick={onClick}
        className={cn(
          'w-12 h-12 rounded-2xl transition-all duration-300 relative',
          active ? 'bg-primary/10 text-primary' : 'hover:bg-accent opacity-70 hover:opacity-100'
        )}
        title={label}
      >
        <Icon className={cn('w-5 h-5', active && 'scale-110')} />
      </Button>
    </div>
  )
}

function LogoSection() {
  return (
    <div className="flex flex-col items-center group select-none">
      <div className="flex flex-col items-center gap-1">
        <div className="flex items-center justify-center gap-0.5">
          <span className="text-2xl font-black text-rose-500">7</span>
          <span className="text-2xl font-black text-rose-500/40">7</span>
        </div>
        <span className="text-[8px] font-bold text-muted-foreground uppercase tracking-[0.3em]">Cafe</span>
      </div>
    </div>
  )
}

function LoadingFallback() {
  return (
    <div className="flex items-center justify-center h-full">
      <motion.div 
        initial={{ opacity: 0 }} 
        animate={{ opacity: 1 }}
        className="flex flex-col items-center gap-2"
      >
        <Loader2 className="w-8 h-8 animate-spin text-primary" />
        <span className="text-xs text-muted-foreground font-medium">Yükleniyor...</span>
      </motion.div>
    </div>
  )
}

export default App
Neden "Daha İyi"?

Görsel Akıcılık (UX): AnimatePresence mode="wait" kullanarak eski görünümün tamamen kaybolup yenisinin gelmesini sağladık. layoutId ile Sidebar'daki aktif göstergesini (çizgi) "akıllı" (magic move) hale getirdik; çizgi bir düğmeden diğerine kayarak gider.

Modülerlik (Quality): NavButton ve LogoSection gibi parçaları ayırdık. useTheme hook'u sayesinde tema mantığı artık merkezi.

Performans (Speed):

useCallback kullanımı sayesinde TablesView veya OrderView gibi alt bileşenler her render'da yeni fonksiyon referansı almaz, bu da memo kullanıldığında gereksiz render'ları keser.

gpu-accelerated sınıfları yerine Framer Motion'ın kendi transform optimizasyonlarına güvendik.

Hata Yönetimi ve Suspense: Suspense kullanımı sayesinde lazy-load edilen SettingsView yüklenirken kullanıcı beyaz ekran yerine şık bir loader görür.

Temiz Kod: App bileşenindeki "kalabalık" (useEffect'ler, karmaşık Tailwind string'leri) azaltıldı.

Tavsiye: State Yönetimi (Zustand/Router)

Eğer uygulama büyürse, currentView bilgisini bir URL state'i (örn: react-router veya TanStack Router) olarak tutmanız daha iyidir. Böylece kullanıcı tarayıcıda "geri" tuşuna bastığında bir önceki sayfaya dönebilir. Şu anki haliyle "geri" tuşu tüm uygulamayı kapatabilir veya başa sarabilir.